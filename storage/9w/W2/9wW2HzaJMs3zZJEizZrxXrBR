class OrdersController < ApplicationController
  before_action :set_product, only: [:add_to_cart, :add_quantity, :reduce_quantity, :remove_item, :select_size, :select_color]
  before_action :own_cart, only: [:checkout, :save_order]
  before_action :own_stock, only: [:add_to_cart, :add_quantity]

  def cart
    cart_items(true)
    set_meta_tags title: 'Your Cart',
                  description: 'Guldozi. Place your favorite products in your shopping cart',
                  keywords: 'My Cart. My Orders. Check Out. Order Summary'
  end

  def add_to_cart
    if @stock_flag
      session[:cart] = {} if session[:cart].blank?
      session[:cart].merge!(@product.add_in_cart) unless session[:cart].key?(@product.key_for_cart)
      @product.set_quantity(session[:cart])
      set_color_in_cart
      set_size_in_cart
    end
    @wishlist_prods = current_user&.wishlist_products || []
    @compare_products = Product.where(slug: Product.compare_attr(session[:compare_products], 'slug')) if session[:compare_products].present?

    respond_to do |format|
      format.js
      format.html { redirect_to cart_orders_path }
    end
  end

  def add_quantity
    if @stock_flag
      quantity = @product.get_quantity(session[:cart])
      @product.set_quantity(session[:cart], quantity + 1)
    end
    cart_items
  end

  def reduce_quantity
    quantity = @product.get_quantity(session[:cart])
    @product.set_quantity(session[:cart], quantity - 1) if quantity > 1
    cart_items
  end

  def remove_item
    key = @product.key_for_cart
    if session[:cart].delete(key)
      flash[:notice] = 'Item has been removed'
    else
      flash[:alert]  = 'Cart product not deleted'
    end
    cart_items
    @wishlist_prods = current_user&.wishlist_products || []
    render js: "window.location = '#{cart_orders_path}'" if session[:cart].empty? && params[:source] == 'checkout'
  end

  def select_size
    @product.set_size(session[:cart], params[:size].to_i)
  end

  def select_color
    @product.set_color(session[:cart], params[:color].to_i)
  end

  def checkout
    @addresses   = current_user&.addresses
    @wire_detail = WireDetail.first
    cart_items

    set_meta_tags title: 'Checkout',
                  description: 'Guldozi. Proceed to checkout',
                  keywords: 'My Cart. Check Out. Order. Billing. Payment. Shipping'
  end

  def save_order
    return redirect_to checkout_orders_path, alert: 'Please set address & payment method' if params[:order].blank?

    cart_items(true)
    @order = current_user.orders.new(order_params.merge!(sub_total: @sub_total))

    Order.transaction do
      if @order.save
        begin
          create_order_items
          deduct_stock
          session.delete(:cart)
          UserMailer.delay.order_placement(current_user, @order.id) if current_user.settings[:order_placement]
          AdminMailer.delay.order_detail(current_user, @order.id)
          redirect_to order_complete_order_path(@order), notice: 'Order registered successfully'
        rescue StandardError => e
          Rails.logger.error "Order rollback ===> #{e.message}"
          redirect_to checkout_orders_path, alert: 'Oops! something went wrong.'
          raise ActiveRecord::Rollback
        end
      else
        redirect_to checkout_orders_path, alert: @order.errors.full_messages.join(', ')
      end
    end
  end

  def order_complete
    return redirect_to root_path, alert: 'This order does not belongs to you.' unless current_user.orders.exists?(params[:id])

    @order         = Order.includes(:address, order_items: [:size, :color, product: [:images]]).find params[:id]
    @have_feedback = current_user.feedbacks.present?

    set_meta_tags title: 'Order Processed',
                  description: 'Your order has successfully been processed.',
                  keywords: 'Guldozi, Success, Processed, Order, Complete'
  end

  def save_feedback
    order    = Order.find params[:id]
    feedback = order.feedbacks.create(feedback_params.merge!(user_id: current_user.id))
    UserMailer.delay.feedback(current_user)
    AdminMailer.delay.new_feedback(current_user, feedback)
  end

  private

    def cart_items(including = false)
      ids = session[:cart]&.keys&.map { |key| Product.item_id_from_cart(key) }
      @products = if including
                    Product.includes(:images, :sizes, :colors, sub_category: [category: [:section]]).where(id: ids)
                  else
                    Product.where(id: ids)
                  end
      @sub_total = Product.calculate_sub_total(@products, session[:cart])
    end

    def set_product
      @product = Product.friendly.find params[:product_id]
    end

    def own_cart
      return redirect_to root_path, alert: 'Your cart is empty' if session[:cart].blank?
    end

    def own_stock
      @stock_flag = @product.in_stock && @product.add_within_stock?(session[:cart])
    end

    def order_params
      params.require(:order).permit(:payment_method, :address_id)
    end

    def feedback_params
      params.require(:feedback).permit(:experience, :recommend, :hear, :suggestion, :hear_source)
    end

    def create_order_items
      records = []
      @products.each do |product|
        records << product.order_items.new(
          order: @order,
          quantity: product.get_quantity(session[:cart]), total: product.get_total(session[:cart]),
          color_id: product.get_color(session[:cart]), size_id: product.get_size(session[:cart])
        )
      end
      OrderItem.import(records)
    end

    def deduct_stock
      records = []
      @products.each do |product|
        product.stock = (product.stock - product.get_quantity(session[:cart]))
        records << product
      end
      Product.import records, on_duplicate_key_update: [:stock]
    end

    def set_color_in_cart
      if params[:color].present?
        @product.set_color(session[:cart], params[:color].to_i)
      elsif @product.colors.present?
        @product.set_color(session[:cart], @product.colors.first.id)
      end
    end

    def set_size_in_cart
      if params[:size].present?
        @product.set_size(session[:cart], params[:size].to_i)
      elsif @product.sizes.present?
        @product.set_size(session[:cart], @product.sizes.first.id)
      end
    end
end
