class Product < ApplicationRecord
  include Taggable
  include Colors
  include Sizes
  include Search
  extend FriendlyId
  friendly_id :slug_candidates, use: :slugged
  ratyrate_rateable 'quality', 'price', 'delivery'

  COMPARE_MAX = 3
  COMPARE_MIN = 2
  CART        = 'product_'.freeze
  SECTION     = 'sc_'.freeze
  CATEGORY    = 'cg_'.freeze
  SUBCATEGORY = 'scg_'.freeze
  TAG         = 'tag_'.freeze
  COLOR       = 'cl_'.freeze
  SIZE        = 'sz_'.freeze
  PRICE       = 'pr_'.freeze
  SORT        = {
    recent_first: 'updated_at-desc',
    oldest_first: 'updated_at-asc',
    price_low_to_high: 'price-asc',
    price_high_to_low: 'price-desc'
  }.freeze

  belongs_to :sub_category

  has_many :images, as: :imageable, dependent: :destroy
  has_many :order_items
  has_many :orders, through: :order_items
  has_many :wishlists, dependent: :destroy
  has_many :wishlist_users, through: :wishlists, source: :user
  has_many :reviews, dependent: :destroy
  has_many :review_users, through: :reviews, source: :user
  has_many :stock_subscribers, dependent: :destroy

  validates :name, :description, :price, :selling_type, :images, :stock, presence: true
  validates_numericality_of :price, :stock
  validates_numericality_of :discounted_price, allow_blank: true

  scope :of_selling_type, ->(selling_type) { where(selling_type: selling_type) }
  scope :of_delivered_orders, ->(user) { joins(:orders).where('orders.status = ? AND orders.user_id = ?', Order.statuses[:delivered], user).distinct }

  enum selling_type: [:new_arrival, :featured, :best_seller, :special, :sale, :popular]

  accepts_nested_attributes_for :images, reject_if: :all_blank, allow_destroy: true

  def primary_image
    images.detect(&:is_primary)
  end

  def discount_percentage
    100 - ((read_attribute(:discounted_price) / read_attribute(:price)) * 100).round(0)
  end

  def in_stock
    stock.positive?
  end

  def add_within_stock?(cart)
    !cart&.key?(key_for_cart) || (stock >= (get_quantity(cart) + 1))
  end

  def price
    read_attribute(:price)&.round(0)
  end

  def discounted_price
    read_attribute(:discounted_price)&.round(0)
  end

  def ratings
    rates   = Rate.of_product(id)
    ratings = {}
    rates&.each do |rate|
      ratings[rate.rater_id] = {} unless ratings.key?(rate.rater_id)
      ratings[rate.rater_id].merge!("#{rate.dimension}": rate.stars)
    end
    ratings
  end

  def add_in_cart
    { "#{CART}#{id}": {} }.stringify_keys
  end

  def set_quantity(cart, quantity = 1)
    cart[key_for_cart].merge!({ "quantity": quantity }.stringify_keys)
  end

  def get_quantity(cart)
    cart[key_for_cart]['quantity']
  end

  def get_total(cart)
    if discounted_price.present?
      discounted_price * get_quantity(cart)
    else
      price * get_quantity(cart)
    end
  end

  def set_size(cart, size)
    cart[key_for_cart].merge!({ "size": size }.stringify_keys)
  end

  def get_size(cart)
    cart&.dig(key_for_cart)&.dig('size')
  end

  def set_color(cart, color)
    cart[key_for_cart].merge!({ "color": color }.stringify_keys)
  end

  def get_color(cart)
    cart&.dig(key_for_cart)&.dig('color')
  end

  def key_for_cart
    "#{CART}#{id}"
  end

  class << self
    def item_id_from_cart(key)
      key.sub(CART, '')
    end

    def calculate_sub_total(products, cart)
      total = 0
      products.map { |product| total += product.get_total(cart) }
      total
    end

    def apply_sort(sort)
      sort = sort.tr('-', ' ')
      order(sort)
    end

    def compare_attr(cart, atr)
      cart&.map { |item| item[atr] } || []
    end

    def search_product(title)
      q = "%#{title.downcase}%"
      where('lower(title) LIKE :q', q: q)
    end

    def filter_by_stock(stock)
      case stock
      when 'stock_in'
        where('stock > ?', 0)
      when 'stock_out'
        where('stock <= ?', 0)
      end
    end

    def average_ratings(product_ids)
      average_ratings = RatingCache.of_product(product_ids)
      avg_hash        = {}
      average_ratings&.each do |ar|
        avg_hash[ar.cacheable_id] = {} unless avg_hash.key?(ar.cacheable_id)
        avg_hash[ar.cacheable_id].merge!("#{ar.dimension}": ar.avg)
      end
      avg_hash
    end
  end

  private

    def slug_candidates
      [
        [title, uid]
      ]
    end

    def should_generate_new_friendly_id?
      self.uid   = Digest::SHA1.hexdigest(Time.now.to_s)[0..5] if uid.blank?
      self.title = name.to_s
      slug.blank? || title_changed?
    end
end
